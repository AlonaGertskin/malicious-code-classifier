#include <libwebsockets.h>
#include <stdio.h>

/*
 * This callback is called by LEJP each time it finds something interesting.
 */
static signed char
lejp_cb(struct lejp_ctx *ctx, char reason)
{
    printf("Reason=%d, path='%s', buf='%s'\n", reason, ctx->path, ctx->buf);

    return 0;
}

int main(void) {
   const char * const paths[] = {
        "schema",
        "uid",
        "len",
        "timestamp",
        "channel",
        "finished",
        "task_uuid"
    };

    struct lejp_ctx ctx;
    const char *json = "{\"schema\":\"xxx\", \"uid\":1004, \"len\":194, \"timestamp\":1641458307868, \"channel\":2, \"finished\":0, \"task_uuid\":\"2a31db22f1180d77734ccaee5af18472c733bce4078405eadc8568d8173eb855\"}";

    /* Initialize parser context */
    lejp_construct(&ctx, lejp_cb, NULL, paths, LWS_ARRAY_SIZE(paths));

    /* Parse the JSON string */
    lejp_parse(&ctx, (uint8_t *)json, strlen(json));

    /* Clean up */
    lejp_destruct(&ctx);

    return 0;
}

# --- New Code Block --- 

Reason=0, path='�   ', buf=''
Reason=2, path='�   ', buf=''
Reason=16, path='�  ', buf=''
Reason=5, path='�   ', buf=''
Reason=11, path='', buf=''
Reason=77, path='xxx', buf=''
Reason=5, path='xxx', buf=''
Reason=73, path='1004', buf=''
Reason=5, path='1004', buf=''
Reason=73, path='194', buf=''
Reason=5, path='194', buf=''
Reason=73, path='1641458307868', buf=''
Reason=5, path='1641458307868', buf=''
Reason=73, path='2', buf=''
Reason=5, path='2', buf=''
Reason=73, path='0', buf=''
Reason=5, path='0', buf=''
Reason=11, path='', buf=''
Reason=77, path='2a31db22f1180d77734ccaee5af18472c733bce4078405eadc8568d8173eb855', buf=''
Reason=17, path='2a31db22f1180d77734ccaee5af18472c733bce4078405eadc8568d8173eb855', buf=''
Reason=3, path='2a31db22f1180d77734ccaee5af18472c733bce4078405eadc8568d8173eb855', buf=''
Reason=1, path='2a31db22f1180d77734ccaee5af18472c733bce4078405eadc8568d8173eb855', buf=''

# --- New Code Block --- 

Reason=0, path='', buf='<��v'
Reason=2, path='', buf='<��v'
Reason=16, path='', buf='<��v'
Reason=5, path='schema', buf='<��v'
Reason=11, path='schema', buf=''
Reason=77, path='schema', buf='xxx'
Reason=5, path='uid', buf='xxx'
Reason=73, path='uid', buf='1004'
Reason=5, path='len', buf='1004'
Reason=73, path='len', buf='194'
Reason=5, path='timestamp', buf='194'
Reason=73, path='timestamp', buf='1641458307868'
Reason=5, path='channel', buf='1641458307868'
Reason=73, path='channel', buf='2'
Reason=5, path='finished', buf='2'
Reason=73, path='finished', buf='0'
Reason=5, path='task_uuid', buf='0'
Reason=11, path='task_uuid', buf=''
Reason=77, path='task_uuid', buf='2a31db22f1180d77734ccaee5af18472c733bce4078405eadc8568d8173eb855'
Reason=17, path='task_uuid', buf='2a31db22f1180d77734ccaee5af18472c733bce4078405eadc8568d8173eb855'
Reason=3, path='task_uuid', buf='2a31db22f1180d77734ccaee5af18472c733bce4078405eadc8568d8173eb855'
Reason=1, path='task_uuid', buf='2a31db22f1180d77734ccaee5af18472c733bce4078405eadc8568d8173eb855'

# --- New Code Block --- 

struct lejp_ctx {

    /* sorted by type for most compact alignment
     *
     * pointers
     */
    void *user;

    /* arrays */

    struct _lejp_parsing_stack pst[LEJP_MAX_PARSING_STACK_DEPTH];
    struct _lejp_stack st[LEJP_MAX_DEPTH];
    uint16_t i[LEJP_MAX_INDEX_DEPTH]; /* index array */
    uint16_t wild[LEJP_MAX_INDEX_DEPTH]; /* index array */
    char path[LEJP_MAX_PATH];
    char buf[LEJP_STRING_CHUNK + 1];

    /* size_t */

    size_t path_stride; /* 0 means default ptr size, else stride */

    /* int */

    uint32_t line;

    /* short */

    uint16_t uni;
#define LEJP_FLAG_FEAT_OBJECT_INDEXES               (1 << 0)
#define LEJP_FLAG_FEAT_LEADING_WC               (1 << 1)
#define LEJP_FLAG_LATEST \
                    (LEJP_FLAG_FEAT_OBJECT_INDEXES | \
                     LEJP_FLAG_FEAT_LEADING_WC)
    uint16_t flags;

    /* char */

    uint8_t npos;
    uint8_t dcount;
    uint8_t f;
    uint8_t sp; /* stack head */
    uint8_t ipos; /* index stack depth */
    uint8_t count_paths;
    uint8_t path_match;
    uint8_t path_match_len;
    uint8_t wildcount;
    uint8_t pst_sp; /* parsing stack head */
    uint8_t outer_array;
};
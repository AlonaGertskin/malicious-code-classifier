import multiprocessing
from flask import Flask, render_template
from flask_socketio import SocketIO
import time

app = Flask(__name__)
# Declared outside of frontend so that other processes can emit from it
socketio = SocketIO(app) 

# The process function to run the frontend software
def runHTML():
    @app.route('/')
    def index():
        return render_template('index.html')
    
    @socketio.on('connect')
    def handle_connect():
        print('Client connected')

    @socketio.on('getdata')
    def handle_message(data):
        print("sending data to frontend")
        socketio.emit('update', "update for frontend")

    socketio.run(app)

if __name__ == "__main__":
    # Create another process to allow clients to connect to the html script
    frontendProcess = multiprocessing.Process(target=runHTML)
    frontendProcess.start()

    counter = 0

    while(1):
        counter += 1
        socketio.emit('update', str(counter)) # Send data to frontend
        print("sending a " + str(counter))
        time.sleep(1)

# --- New Code Block --- 

<!DOCTYPE html>
<html>
    <head>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js" integrity="sha512-q/dWJ3kcmjBLU4Qc47E4A9kTB4m3wuTY7vkFJDTZKjTs8jhyGQnaUrxa0Ytd0ssMZhbNua9hE+E7Qv1j+DyZwA==" crossorigin="anonymous"></script>
    </head>
<body>

<h1 id="updatethis">Text to update</h1>
<button id="button_1" onclick=requestData()>Update</button>
<script>
    var text = document.getElementById("updatethis");
    var button1 = document.getElementById("button_1");
    // Socket to communicate with frontend
    var socket = io();

    socket.on('update', function(data) {
        console.log('Received data to display...');
        text.innerHTML = "Number: " +data + "\n";
    });

    function requestData() {
        socket.emit('getdata', '1');
    }
</script>
</body>
</html>